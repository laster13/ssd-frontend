<script lang="ts">
    import { onMount } from 'svelte';
    import { writable, derived, get } from 'svelte/store';
    import { FolderSearch, ChevronDown, Search, Eye, Sparkles, FolderOpen, Trash, Clock, Folder, RefreshCw, Info, Scan, Download, Upload, Filter, Trash2, Loader2, CheckCircle2, Tv } from 'lucide-svelte';
    import { goto } from '$app/navigation';
    import Pagination from '$lib/components/Pagination.svelte';

    // Base URL selon dev/prod
    const baseURL = import.meta.env.DEV
      ? import.meta.env.VITE_BACKEND_URL_HTTP
      : import.meta.env.VITE_BACKEND_URL_HTTPS;

    const symlinks = writable<any[]>([]);
    const search = writable('');
    const rowsPerPage = writable(10);
    const currentPage = writable(1);
    const scanStatus = writable(false);
    const selected = writable<any[]>([]);
    const showOrphansOnly = writable(false);
    const logs = writable<string[]>([]);
    const totalItems = writable(0);
    const orphaned = writable(0);
    const uniqueTargets = writable(0);

    const exporting = writable(false);
    const exportSuccess = writable(false);

    const importing = writable(false);
    const importSuccess = writable(false);

    const refreshing = writable(false);
    const refreshSuccess = writable(false);

    const scanning = writable(false);
    const scanSuccess = writable(false);

    const deleting = writable<Record<string, boolean>>({});
    const deleteSuccess = writable<Record<string, boolean>>({});

    const selectedDir = writable('');            // 'shows' | 'movies' | '' (toutes racines)
    const availableDirs = writable<string[]>([]); // renvoy√© par /symlinks/folders : ["shows","movies"]

    const bulkDeleting = writable(false);
    const bulkDeleteSuccess = writable(false);

    const repairing = writable(false);
    const repairSuccess = writable(false);

    let menu: HTMLDetailsElement;
    let sortedColumn: string | null = null;
    let ascending = true;
    let mounted = false;
    export const allBrokenCount = writable(0);
    export const showDuplicatesOnly = writable(false);
    export const latestSymlinks = writable<any[]>([]);
    const showLatest = writable(false);
    const hasDuplicates = writable(false);

    const filteredSymlinks = derived(
        [symlinks, search],
        ([$symlinks, $search]) =>
            $symlinks.filter((item: any) =>
                item.symlink.toLowerCase().includes($search.toLowerCase()) ||
                item.target.toLowerCase().includes($search.toLowerCase())
            )
    );

    let searchTerm = '';
    $: searchTerm = $search.trim();

    $: if (mounted && $search !== undefined) {
        currentPage.set(1);
        refreshList();
    }

    $: if (mounted && $showOrphansOnly !== undefined) {
        refreshList();
    }

    $: if (mounted && $showDuplicatesOnly !== undefined) {
        loadSymlinks();
    }

    function handleAndClose(action: () => void) {
        action();
        menu?.removeAttribute('open');
    }

    function goToPage(p: number) {
      currentPage.set(p);
      refreshList();
    }

    async function openArr(item: any) {
        console.log("üî• [openArr] d√©clench√©");
        console.log("   ‚û°Ô∏è type:", item.type, "| symlink:", item.symlink);

        const { root, relative } = relativeToRoot(item.symlink);
        console.log("   üìÇ relativeToRoot ‚Üí", { root, relative });

        if (!relative || !root) {
            console.warn("   ‚ùå root/relative vide ‚Üí arr√™t avant fetch");
            alert("Impossible de d√©terminer le chemin relatif √† la racine.");
            return;
        }

        try {
            let route = "";
            if (item.type.toLowerCase() === "sonarr") {
                // S√©rie ‚Üí on garde relative complet
                route = `/api/v1/symlinks/get-sonarr-url/${encodeURIComponent(relative)}`;
            } else if (item.type.toLowerCase() === "radarr") {
                // Film ‚Üí on prend seulement le dossier parent
                const relativeDir = relative.split("/")[0];
                console.log("   üé¨ Radarr ‚Üí dossier parent utilis√©:", relativeDir);
                route = `/api/v1/symlinks/get-radarr-url/${encodeURIComponent(relativeDir)}`;
            } else {
                console.warn("   ‚ùå type non support√©:", item.type);
                return;
            }

            console.log("   üì° Route construite:", route);
            console.log("   üåç URL compl√®te:", `${baseURL}${route}`);

            const res = await fetch(`${baseURL}${route}`);
            console.log("   üì• R√©ponse brute fetch:", res);

            if (!res.ok) {
                console.error("   ‚ùå Erreur HTTP:", res.status);
                throw new Error(`HTTP ${res.status}`);
            }

            const json = await res.json();
            console.log("   ‚úÖ R√©ponse JSON backend:", json);

            // Redirection finale
            window.location.href = json.url;
        } catch (e: any) {
            console.error("   üí• Exception dans openArr:", e);
            alert(`Erreur ouverture ${item.type}: ${e?.message || e}`);
        }
    }

    async function loadLatestSymlinks() {
        try {
            const searchTermVal = get(search);
            const folder = get(selectedDir);  // 'shows' | 'movies' | ''
            const orphansOnly = get(showOrphansOnly);

            const params = new URLSearchParams({
                sort: "created_at",
                order: "desc",
                limit: "10"
            });

            if (searchTermVal.trim()) params.append("search", searchTermVal.trim());
            if (folder) params.append("folder", folder);
            if (orphansOnly) params.append("orphans", "true");

            const res = await fetch(`${baseURL}/api/v1/symlinks?${params.toString()}`);
            if (!res.ok) throw new Error("Erreur chargement derniers symlinks");

            const json = await res.json();
            latestSymlinks.set(json.data || []);
        } catch (e) {
            console.error("‚ùå loadLatestSymlinks:", e);
            latestSymlinks.set([]);
        }
    }

    // --------- util: chemin relatif √† la racine ---------
    function relativeToRoot(absPath: string): { root: string | null, relative: string } {
        // On essaie de rep√©rer le segment '/<racine>/' dans le chemin absolu, √† partir de la liste des racines
        const roots = get(availableDirs); // ex: ['shows', 'movies']
        if (!absPath) return { root: null, relative: '' };

        // Normaliser s√©parateurs (au cas o√π)
        const norm = absPath.replace(/\\/g, '/');

        for (const r of roots) {
            const needle = `/${r}/`;
            const idx = norm.indexOf(needle);
            if (idx !== -1) {
                const rel = norm.substring(idx + needle.length); // tout ce qui vient apr√®s '<racine>/'
                return { root: r, relative: rel };
            }
        }

        // Si pas trouv√©, on tente une autre strat√©gie: r√©cup√©rer la derni√®re racine plausible
        // (s√©curise un peu mais on pr√©f√®re retourner vide plut√¥t que casser)
        return { root: null, relative: '' };
    }

    async function repairMissingSeasons() {
      if (get(repairing)) return;

      repairing.set(true);
      repairSuccess.set(false);

      try {
        const folder = get(selectedDir); // 'shows' | 'movies' | ''
        const url = `${baseURL}/api/v1/symlinks/repair-missing-seasons` + (folder ? `?folder=${encodeURIComponent(folder)}` : '');

        const res = await fetch(url, { method: 'POST' });
        if (!res.ok) {
          const text = await res.text().catch(() => '');
          throw new Error(text || `HTTP ${res.status}`);
        }

        const json = await res.json().catch(() => ({}));
        logs.update(l => [
          `üõ†Ô∏è R√©paration effectu√©e${json.symlinks_deleted !== undefined ? ` ‚Äî ${json.symlinks_deleted} symlink(s) supprim√©(s)` : ''}`,
          ...l
        ]);

        repairSuccess.set(true);
        setTimeout(() => repairSuccess.set(false), 2500);

        await refreshList();
      } catch (e: any) {
        console.error('repairMissingSeasons:', e);
        alert(`‚ùå √âchec de la r√©paration: ${e?.message || e}`);
      } finally {
        repairing.set(false);
      }
    }

    async function loadSymlinks() {
        const isDuplicateMode = get(showDuplicatesOnly);
        const url = isDuplicateMode
            ? `${baseURL}/api/v1/symlinks/duplicates`
            : `${baseURL}/api/v1/symlinks?page=1&limit=50`;

        try {
            const res = await fetch(url);
            if (!res.ok) throw new Error('Erreur chargement');

            const json = await res.json();
            symlinks.set(json.data);
            totalItems.set(json.total || json.data?.length || 0);

            // V√©rification des doublons
            try {
                const dupRes = await fetch(`${baseURL}/api/v1/symlinks/duplicates`);
                if (dupRes.ok) {
                    const dupJson = await dupRes.json();
                    const hasSome = (dupJson.total || 0) > 0;
                    hasDuplicates.set(hasSome);
                    if (isDuplicateMode && !hasSome) {
                        showDuplicatesOnly.set(false);
                    }
                } else {
                    hasDuplicates.set(false);
                }
            } catch {
                hasDuplicates.set(false);
            }
        } catch (e) {
            console.error("‚ùå loadSymlinks:", e);
        }
    }

    // Nombre de symlinks cass√©s
    $: brokenCount = $symlinks.filter((i: any) => i.ref_count === 0 || i.target_exists === false).length;

    function sortBy(column: string) {
        if (sortedColumn === column) {
            ascending = !ascending;
        } else {
            sortedColumn = column;
            ascending = true;
        }
        refreshList();
    }

    const totalPages = derived([totalItems, rowsPerPage], ([$total, $perPage]) =>
        Math.ceil($total / $perPage)
    );

    function s(count: number) {
        return count > 1 ? 's' : '';
    }

    async function deleteAllBrokenSymlinks() {
        if (!confirm("üóëÔ∏è Supprimer tous les symlinks cass√©s s√©lectionn√©s ?")) return;

        const folderRaw = get(selectedDir);
        const folder = (folderRaw ?? '').toString().trim(); // nom choisi par l‚Äôutilisateur

        // Construction des routes selon le dossier choisi
        let routes: string[] = [];
        if (folder) {
            // Si une racine est choisie ‚Üí on essaie les deux APIs avec ce nom
            routes = [
                `/api/v1/symlinks/delete_broken_sonarr?folder=${encodeURIComponent(folder)}`,
                `/api/v1/symlinks/delete_broken?folder=${encodeURIComponent(folder)}`
            ];
        } else {
            // Si aucune racine s√©lectionn√©e ‚Üí on lance les deux globalement
            routes = [
                '/api/v1/symlinks/delete_broken_sonarr',
                '/api/v1/symlinks/delete_broken'
            ];
        }

        // Debug : afficher ce qui part
        console.log("deleteAllBrokenSymlinks | routes=", routes);
        logs.update(l => [
            `üß≠ deleteAllBrokenSymlinks | folder='${folder || '(all)'}' | routes=${routes.join(', ')}`,
            ...l
        ]);

        bulkDeleting.set(true);
        bulkDeleteSuccess.set(false);

        const tasks = routes.map(async (route) => {
            try {
                const res = await fetch(`${baseURL}${route}`, { method: 'POST' });
                if (!res.ok) {
                    const text = await res.text().catch(() => '');
                    logs.update(l => [`‚ùå ${route} ‚Äî ${text || `HTTP ${res.status}`}`, ...l]);
                    return 0;
                }
                const json = await res.json().catch(() => ({} as any));
                const deleted = Number(json.deleted) || 0;
                logs.update(l => [`‚úÖ ${deleted} supprim√©(s) via ${route}`, ...l]);
                return deleted;
            } catch (e: any) {
                logs.update(l => [`‚ùå R√©seau ${route} ‚Äî ${e?.message || e}`, ...l]);
                return 0;
            }
        });

        const results = await Promise.allSettled(tasks);
        const totalDeleted = results.reduce(
            (sum, r) => sum + (r.status === 'fulfilled' ? (r.value as number) : 0),
            0
        );

        logs.update(l => [`üßπ Total supprim√© : ${totalDeleted}`, ...l]);
        bulkDeleteSuccess.set(true);
        setTimeout(() => bulkDeleteSuccess.set(false), 3000);

        try {
            await refreshList();
        } finally {
            bulkDeleting.set(false);
        }
    }

    async function loadAvailableDirs() {
        try {
            const foldersRes = await fetch(`${baseURL}/api/v1/symlinks/folders`);
            if (foldersRes.ok) {
                const folders = await foldersRes.json(); // ex: ["shows","movies"]
                availableDirs.set(folders);
            }
        } catch (e) {
            console.error('Erreur chargement dossiers :', e);
        }
    }

    function changePage(offset: number) {
        currentPage.update(n => {
            const newPage = Math.max(1, n + offset);
            refreshList();
            return newPage;
        });
    }

    function toggleSelected(item: any) {
        selected.update(list =>
            list.includes(item) ? list.filter(i => i !== item) : [...list, item]
        );
    }

    function viewSymlink(item: any) {
        alert(`Symlink: ${item.symlink}\nTarget: ${item.target}\nRef Count: ${item.ref_count}`);
    }


    async function deleteSymlink(item: any) {
        if (item.type === 'sonarr') {
            // üö´ On ne supprime pas le symlink c√¥t√© backend
            // ‚ûú Appel au nouvel endpoint qui renvoie juste l‚ÄôID Sonarr
            const { root, relative } = relativeToRoot(item.symlink);
            if (!relative || !root) {
                alert("Impossible de d√©terminer le chemin relatif √† la racine.");
                return;
            }

            const route = `/api/v1/symlinks/get-sonarr-id/${encodeURIComponent(relative)}?root=${encodeURIComponent(root)}`;
            try {
                const res = await fetch(`${baseURL}${route}`);
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                const json = await res.json();
                // ‚úÖ Redirection vers la page de la s√©rie
                window.location.href = `${import.meta.env.VITE_BACKEND_URL_HTTPS}/season/shows/${json.id}`;
            } catch (e) {
                alert(`Erreur r√©cup√©ration ID Sonarr : ${e}`);
            }
            return; // on sort ici, pas de suppression
        }

        // üóëÔ∏è Suppression classique pour les autres types (Radarr, etc.)
        const { root, relative } = relativeToRoot(item.symlink);
        if (!relative || !root) {
            alert("Impossible de d√©terminer le chemin relatif √† la racine.");
            return;
        }

        const route = `/api/v1/symlinks/delete/${encodeURIComponent(relative)}`;
        deleting.update(state => ({ ...state, [item.symlink]: true }));
        deleteSuccess.update(state => ({ ...state, [item.symlink]: false }));

        try {
            const res = await fetch(`${baseURL}${route}`, { method: 'DELETE' });
            if (!res.ok) {
                const error = await res.json().catch(() => ({}));
                console.warn(`Suppression locale uniquement : ${error.detail || res.status}`);
            }
            logs.update(list => [`üóëÔ∏è Supprim√© : ${item.symlink}`, ...list]);
            deleteSuccess.update(state => ({ ...state, [item.symlink]: true }));
            setTimeout(() => {
                deleteSuccess.update(state => ({ ...state, [item.symlink]: false }));
            }, 2000);
            await refreshList();
        } catch {
            alert('Erreur r√©seau lors de la suppression');
        } finally {
            deleting.update(state => ({ ...state, [item.symlink]: false }));
        }
    }

    function exportJSON() {
        exporting.set(true);
        exportSuccess.set(false);
        symlinks.subscribe((data: any[]) => {
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'symlinks_backup.json';
            a.click();
            URL.revokeObjectURL(url);
            exporting.set(false);
            exportSuccess.set(true);
            setTimeout(() => exportSuccess.set(false), 2000);
        })();
    }

    function importJSON(event: Event) {
        const file = (event.target as HTMLInputElement).files?.[0];
        if (!file) return;
        importing.set(true);
        importSuccess.set(false);

        const reader = new FileReader();
        reader.onload = () => {
            try {
                const imported = JSON.parse(String(reader.result));
                symlinks.set(imported);
                logs.update(list => [`Imported ${imported.length} symlinks`, ...list]);
                importSuccess.set(true);
                setTimeout(() => importSuccess.set(false), 2000);
            } catch {
                alert('Invalid JSON');
            } finally {
                importing.set(false);
            }
        };
        reader.readAsText(file);
    }

    async function triggerScan() {
        scanning.set(true);
        scanSuccess.set(false);
        try {
            const res = await fetch(`${baseURL}/api/v1/symlinks/scan`, { method: 'POST' });
            if (res.ok) {
                const json = await res.json();
                symlinks.set(json.data);
                logs.update(l => [`Scan r√©ussi avec ${json.count} liens`, ...l]);
                scanSuccess.set(true);
                setTimeout(() => scanSuccess.set(false), 2000);
            }
        } finally {
            scanning.set(false);
        }
    }

    async function refreshList() {
        refreshing.set(true);
        refreshSuccess.set(false);
        try {
            const page = get(currentPage);
            const limit = get(rowsPerPage);
            const searchTermVal = get(search);
            const orphansOnly = get(showOrphansOnly);
            const sort = sortedColumn || 'symlink';
            const order = ascending ? 'asc' : 'desc';

            const params = new URLSearchParams({
                page: String(page),
                limit: String(limit),
                sort,
                order
            });

            if (searchTermVal.trim()) params.append('search', searchTermVal.trim());
            if (orphansOnly) params.append('orphans', 'true');
            const folder = get(selectedDir);          // 'shows'| 'movies' | ''
            if (folder) params.append('folder', folder);

            const res = await fetch(`${baseURL}/api/v1/symlinks?${params.toString()}`);
            if (!res.ok) throw new Error(`Erreur serveur ${res.status}`);

            const json = await res.json();
            symlinks.set(json.data);
            totalItems.set(json.total);
            orphaned.set(json.orphaned || 0);
            allBrokenCount.set(json.orphaned || 0);
            uniqueTargets.set(json.unique_targets || 0);
            await loadLatestSymlinks();

            logs.update(l => [`Liste rafra√Æchie (page ${json.page})`, ...l]);
            refreshSuccess.set(true);
            setTimeout(() => refreshSuccess.set(false), 2000);

            // V√©rification doublons
            try {
                const dupRes = await fetch(`${baseURL}/api/v1/symlinks/duplicates`);
                if (dupRes.ok) {
                    const dupJson = await dupRes.json();
                    hasDuplicates.set((dupJson.total || 0) > 0);
                } else {
                    hasDuplicates.set(false);
                }
            } catch {
                hasDuplicates.set(false);
            }
        } finally {
            refreshing.set(false);
        }
    }

    // --- suppression en masse des symlinks actuellement filtr√©s (barre de recherche) ---
    async function deleteFilteredSymlinks() {
        const folder = get(selectedDir);                // 'shows' | 'movies' | ''
        const searchTermVal = get(search).trim();

        // r√©cup√©rer la liste "compl√®te" sans pagination pour supprimer tout ce qui matche
        const params = new URLSearchParams();
        params.set('all', 'true');                      // ‚ö† c√¥t√© backend: renvoie tous les items filtr√©s
        if (folder) params.set('folder', folder);
        if (searchTermVal) params.set('search', searchTermVal);

        const res = await fetch(`${baseURL}/api/v1/symlinks?${params.toString()}`);
        if (!res.ok) {
            alert(`Erreur r√©cup√©ration symlinks : ${res.status}`);
            return;
        }
        const json = await res.json();
        const symlinksToDelete: any[] = json.data || [];

        bulkDeleting.set(true);
        bulkDeleteSuccess.set(false);
        const timeout = setTimeout(() => {
            bulkDeleting.set(false);
        }, 5000);

        for (const item of symlinksToDelete) {
            const { root, relative } = relativeToRoot(item.symlink);
            if (!relative || !root) {
                logs.update(l => [`‚ùå Impossible de d√©river le chemin relatif pour ${item.symlink}`, ...l]);
                continue;
            }

            const route =
                item.type === 'sonarr'
                    ? `/api/v1/symlinks/delete-sonarr/${encodeURIComponent(relative)}?root=${encodeURIComponent(root)}`
                    : `/api/v1/symlinks/delete/${encodeURIComponent(relative)}`;

            deleting.update(state => ({ ...state, [item.symlink]: true }));
            deleteSuccess.update(state => ({ ...state, [item.symlink]: false }));

            try {
                const delRes = await fetch(`${baseURL}${route}`, { method: 'DELETE' });
                if (!delRes.ok) {
                    const error = await delRes.json().catch(() => ({}));
                    logs.update(l => [`‚ùå Erreur suppression ${item.symlink} : ${error.detail || delRes.status}`, ...l]);
                    continue;
                }

                logs.update(l => [`üóëÔ∏è Supprim√© : ${item.symlink}`, ...l]);
                deleteSuccess.update(state => ({ ...state, [item.symlink]: true }));
                setTimeout(() => {
                    deleteSuccess.update(state => ({ ...state, [item.symlink]: false }));
                }, 2000);
            } catch {
                logs.update(l => [`‚ùå Erreur r√©seau pour : ${item.symlink}`, ...l]);
            } finally {
                deleting.update(state => ({ ...state, [item.symlink]: false }));
            }
        }

        bulkDeleteSuccess.set(true);
        refreshList();
        setTimeout(() => bulkDeleteSuccess.set(false), 3000);
        bulkDeleting.set(false);
        clearTimeout(timeout);
    }

    onMount(async () => {
        mounted = true;
        await loadAvailableDirs(); // ‚ûú ne liste que les racines (shows, movies)
        await refreshList();
        await loadSymlinks();
        await loadLatestSymlinks(); 
        connectSSE();

        const unsubscribe = showOrphansOnly.subscribe(() => {
            refreshList();
        });

        // Fallback si aucun SSE re√ßu dans les 2s (ex: apres restart)
        setTimeout(() => {
            if (get(showDuplicatesOnly)) {
                loadSymlinks();
            } else {
                refreshList();
            }
        }, 2000);

        return () => {
            unsubscribe();
        };
    });

    function connectSSE() {
        const eventSource = new EventSource(`${baseURL}/api/v1/symlinks/events`);
        eventSource.onmessage = async (event) => {
            try {
                JSON.parse(event.data);
                setTimeout(async () => {
                    if (get(showDuplicatesOnly)) {
                        await loadSymlinks();
                    } else {
                        await refreshList();
                    }
                    await loadLatestSymlinks();
                }, 100);
            } catch {}
        };
        eventSource.onerror = () => {
            eventSource.close();
            setTimeout(() => connectSSE(), 2000);
        };
    }
</script>

<main class="w-full min-h-screen p-4 sm:p-6 md:p-8 space-y-6 bg-white dark:bg-gray-900 text-gray-900 dark:text-gray-200">
  <!-- ‚úÖ Barre d'actions responsive unifi√©e -->
  <div class="flex flex-col md:flex-row md:items-center justify-between gap-4 mb-4">

    <!-- ‚òï Menu mobile -->
    <div class="md:hidden relative">
        <details bind:this={menu} class="relative">
            <summary
                class="flex items-center justify-between px-5 py-3 bg-gradient-to-r from-emerald-600 to-teal-500 text-white rounded-lg shadow-md cursor-pointer text-sm font-semibold tracking-wide transition-transform duration-150 hover:scale-[1.03] focus:outline-none focus:ring-2 focus:ring-emerald-400"
            >
                üåê Tableau de bord
                <ChevronDown class="w-4 h-4 opacity-80 transition-transform duration-200 group-open:rotate-180" />
            </summary>

            <div
                class="absolute z-10 mt-1 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-600 rounded-lg shadow-md p-2 space-y-2 w-full max-w-xs"
            >
                <button
                    on:click={() => handleAndClose(() => showOrphansOnly.update(v => !v))}
                    class="btn btn-emerald-deep w-full justify-start truncate"
                >
                    <Filter class="w-4 h-4" /> Symlinks Bris√©s
                </button>

                <button
                    on:click={() => handleAndClose(repairMissingSeasons)}
                    class="btn btn-indigo-deep w-full justify-start truncate"
                    disabled={$repairing}
                >
                    {#if $repairing}
                        <Loader2 class="w-4 h-4 animate-spin text-white" /> R√©paration...
                    {:else if $repairSuccess}
                        <CheckCircle2 class="w-4 h-4 text-white" /> R√©par√© !
                    {:else}
                        üõ†Ô∏è R√©parer Saisons Incompl√®tes
                    {/if}
                </button>

                <button
                  on:click={() => window.location.href = `${import.meta.env.VITE_BACKEND_URL_HTTPS}/season/dashboard`}
                  class="btn bg-purple-600 hover:bg-purple-700 text-white w-full justify-start truncate"
                >
                  <Tv class="w-4 h-4 text-white" /> Seasonarr
                </button>

                {#if $allBrokenCount > 0}
                    <button
                        on:click={() => handleAndClose(deleteAllBrokenSymlinks)}
                        class="btn btn-red-deep animate-pulse-strong w-full justify-start truncate"
                        disabled={$bulkDeleting}
                    >
                        {#if $bulkDeleting}
                            <Loader2 class="w-4 h-4 animate-spin text-white" /> Suppression...
                        {:else if $bulkDeleteSuccess}
                            <CheckCircle2 class="w-4 h-4 text-white" /> Supprim√©s !
                        {:else}
                            <Trash class="w-4 h-4" /> R√©parer {$allBrokenCount} symlink{s($allBrokenCount)} cass√©{s($allBrokenCount)}
                        {/if}
                    </button>
                {/if}

                {#if $hasDuplicates}
                    <button
                        on:click={() => handleAndClose(() => showDuplicatesOnly.update(v => !v))}
                        class="btn btn-yellow-deep animate-pulse-strong w-full justify-start truncate"
                    >
                        üß† { $showDuplicatesOnly ? 'Afficher tout' : 'Voir les doublons' }
                    </button>
                {/if}

                <button
                    on:click={() => handleAndClose(refreshList)}
                    class="btn btn-blue w-full justify-start truncate"
                >
                    {#if $refreshing}
                        <Loader2 class="w-4 h-4 animate-spin" /> Refreshing
                    {:else if $refreshSuccess}
                        <CheckCircle2 class="w-4 h-4 text-green-500" /> Refreshed
                    {:else}
                        <RefreshCw class="w-4 h-4" /> Refresh
                    {/if}
                </button>

                <button
                    on:click={() => handleAndClose(triggerScan)}
                    class="btn btn-red-deep w-full justify-start truncate"
                >
                    {#if $scanning}
                        <Loader2 class="w-4 h-4 animate-spin" />
                    {:else if $scanSuccess}
                        <CheckCircle2 class="w-4 h-4 text-white" /> Scanned
                    {:else}
                        <Scan class="w-4 h-4" /> Scan
                    {/if}
                </button>

                <!-- ‚úÖ Toggle Derniers symlinks -->
                <button
                    type="button"
                    class="inline-flex items-center gap-3 px-4 py-2 rounded-lg border
                           border-indigo-200 dark:border-indigo-700 
                           bg-indigo-50 dark:bg-indigo-900/40 shadow-sm
                           hover:shadow-md transition-all duration-300
                           cursor-pointer w-full"
                    on:click={() => $showLatest = !$showLatest}
                >
                    <label class="relative inline-flex items-center cursor-pointer select-none">
                        <input type="checkbox" bind:checked={$showLatest} class="sr-only peer" />
                        <div
                            class="w-12 h-6 rounded-full transition-all duration-500
                                   bg-gradient-to-r from-gray-200 to-gray-400 
                                   dark:from-gray-700 dark:to-gray-900
                                   peer-checked:from-pink-500 peer-checked:via-purple-500 peer-checked:to-indigo-500
                                   shadow-inner peer-checked:shadow-[0_0_8px_rgba(236,72,153,0.5)]"
                        ></div>
                        <div
                            class="absolute left-0.5 top-0.5 w-5 h-5 rounded-full 
                                   bg-white dark:bg-gray-100 flex items-center justify-center
                                   transition-all duration-500 ease-in-out
                                   peer-checked:translate-x-6 peer-checked:rotate-[360deg]
                                   shadow-md group-hover:scale-110"
                        >
                            {#if $showLatest}
                                <Sparkles class="w-3.5 h-3.5 text-indigo-600 animate-pulse-slow" />
                            {:else}
                                <FolderOpen class="w-3.5 h-3.5 text-gray-500" />
                            {/if}
                        </div>
                    </label>
                    <span
                        class="text-sm font-medium tracking-wide 
                               bg-gradient-to-r from-indigo-600 via-purple-600 to-pink-600 
                               dark:from-indigo-400 dark:via-purple-400 dark:to-pink-400
                               bg-clip-text text-transparent"
                    >
                        Derniers symlinks
                    </span>
                </button>
                <!-- ‚úÖ Fin Toggle -->

                <button
                    on:click={() => handleAndClose(() => goto('/settings/symlinks/setup'))}
                    class="btn btn-gray w-full justify-start truncate"
                >
                    ‚öôÔ∏è Configuration
                </button>
            </div>
        </details>
    </div>

    <!-- üëà Boutons desktop -->
    <div class="hidden md:flex flex-wrap gap-2">
        <button on:click={() => showOrphansOnly.update(v => !v)} class="btn btn-emerald-deep">
            <Filter class="w-4 h-4" /> Symlinks bris√©s
        </button>

        <button on:click={repairMissingSeasons} class="btn btn-indigo-deep" disabled={$repairing}>
            {#if $repairing}
                <Loader2 class="w-4 h-4 animate-spin text-white" /> R√©paration...
            {:else if $repairSuccess}
                <CheckCircle2 class="w-4 h-4 text-white" /> R√©par√© !
            {:else}
                üõ†Ô∏è R√©parer Saisons Incompl√®tes
            {/if}
        </button>

        <button
          on:click={() => window.location.href = `${baseURL}/season/dashboard`}
          class="btn bg-purple-600 hover:bg-purple-700 text-white"
        >
          <Tv class="w-4 h-4 text-white" /> Seasonarr
        </button>

        <!-- Toggle Derniers symlinks -->
        <button
          type="button"
          class="inline-flex items-center gap-3 px-4 py-2 rounded-lg border
                 border-indigo-200 dark:border-indigo-700 
                 bg-indigo-50 dark:bg-indigo-900/40 shadow-sm
                 hover:shadow-md transition-all duration-300
                 cursor-pointer"
          on:click={() => $showLatest = !$showLatest}
        >
          <!-- Switch -->
          <label class="relative inline-flex items-center cursor-pointer select-none">
            <input type="checkbox" bind:checked={$showLatest} class="sr-only peer" />

            <!-- Track -->
            <div
              class="w-12 h-6 rounded-full transition-all duration-500
                     bg-gradient-to-r from-gray-200 to-gray-400 
                     dark:from-gray-700 dark:to-gray-900
                     peer-checked:from-pink-500 peer-checked:via-purple-500 peer-checked:to-indigo-500
                     shadow-inner peer-checked:shadow-[0_0_8px_rgba(236,72,153,0.5)]"
            ></div>

            <!-- Thumb -->
            <div
              class="absolute left-0.5 top-0.5 w-5 h-5 rounded-full 
                     bg-white dark:bg-gray-100 flex items-center justify-center
                     transition-all duration-500 ease-in-out
                     peer-checked:translate-x-6 peer-checked:rotate-[360deg]
                     shadow-md group-hover:scale-110"
            >
              {#if $showLatest}
                <Sparkles class="w-3.5 h-3.5 text-indigo-600 animate-pulse-slow" />
              {:else}
                <FolderOpen class="w-3.5 h-3.5 text-gray-500" />
              {/if}
            </div>
          </label>

          <!-- Texte -->
          <span
            class="text-sm font-medium tracking-wide 
                   bg-gradient-to-r from-indigo-600 via-purple-600 to-pink-600 
                   dark:from-indigo-400 dark:via-purple-400 dark:to-pink-400
                   bg-clip-text text-transparent"
          >
            Derniers symlinks
          </span>
        </button>

        {#if $hasDuplicates}
            <button
                on:click={() => showDuplicatesOnly.update(v => !v)}
                class="btn btn-yellow-deep animate-pulse-strong"
            >
                üß† { $showDuplicatesOnly ? 'Afficher tout' : 'Voir les doublons' }
            </button>
        {/if}

        {#if $allBrokenCount > 0}
            <button
                on:click={deleteAllBrokenSymlinks}
                class="btn btn-red-deep animate-pulse-strong"
                disabled={$bulkDeleting}
            >
                {#if $bulkDeleting}
                    <Loader2 class="w-4 h-4 animate-spin text-white" /> Suppression...
                {:else if $bulkDeleteSuccess}
                    <CheckCircle2 class="w-4 h-4 text-white" /> Supprim√©s !
                {:else}
                    <Trash class="w-4 h-4" /> R√©parer {$allBrokenCount} symlink{s($allBrokenCount)} cass√©{s($allBrokenCount)}
                {/if}
            </button>
        {/if}
    </div>

    <!-- üî∫ Boutons √† droite -->
    <div class="hidden md:flex flex-wrap gap-2 justify-end">
        <button on:click={refreshList} class="btn btn-blue">
            {#if $refreshing}
                <Loader2 class="w-4 h-4 animate-spin" /> Refreshing
            {:else if $refreshSuccess}
                <CheckCircle2 class="w-4 h-4 text-green-500" /> Refreshed
            {:else}
                <RefreshCw class="w-4 h-4" /> Refresh
            {/if}
        </button>
        <button on:click={triggerScan} class="btn btn-red-deep">
            {#if $scanning}
                <Loader2 class="w-4 h-4 animate-spin" />
            {:else if $scanSuccess}
                <CheckCircle2 class="w-4 h-4 text-white" /> Scanned
            {:else}
                <Scan class="w-4 h-4" /> Scan
            {/if}
        </button>
        <button on:click={() => goto('/settings/symlinks/setup')} class="btn btn-gray">
            ‚öôÔ∏è Configuration
        </button>
    </div>
  </div>

  <!-- Scan en cours -->
  {#if $scanStatus}
    <div class="p-4 bg-yellow-100 dark:bg-yellow-900 text-yellow-800 dark:text-yellow-300 rounded shadow flex items-center gap-2">
      <Info class="w-4 h-4" /> Scan in progress...
    </div>
  {/if}

  <!--  Statistiques -->
  <div class="pl-2 grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-4">
    <div class="bg-gray-100 dark:bg-gray-800 p-4 rounded-xl shadow transition transform hover:scale-[1.02] hover:-translate-y-1 hover:shadow-lg">
      <p class="text-sm text-gray-600 dark:text-gray-400">Total Symlinks</p>
      <h2 class="text-xl font-bold">{$totalItems}</h2>
    </div>
    <div class="bg-gray-100 dark:bg-gray-800 p-4 rounded-xl shadow transition transform hover:scale-[1.02] hover:-translate-y-1 hover:shadow-lg">
      <p class="text-sm text-gray-600 dark:text-gray-400">Symlinks bris√©s</p>
      <h2 class="text-xl font-bold">{$orphaned}</h2>
    </div>
    <div class="bg-gray-100 dark:bg-gray-800 p-4 rounded-xl shadow transition transform hover:scale-[1.02] hover:-translate-y-1 hover:shadow-lg">
      <p class="text-sm text-gray-600 dark:text-gray-400">Cibles uniques</p>
      <h2 class="text-xl font-bold">{$uniqueTargets}</h2>
    </div>
  </div>

  <!-- üîç Champ de recherche + bouton suppression -->
  <div class="flex flex-col sm:flex-row justify-between items-center gap-4 mt-6">
    <div class="flex items-center w-full sm:w-2/3 gap-2 relative">
      <div class="relative flex-grow">
        <input
          bind:value={$search}
          placeholder="Search symlinks..."
          class="w-full border border-gray-300 dark:border-gray-700 bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-200 rounded-lg pl-10 pr-4 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500 placeholder-gray-400 dark:placeholder-gray-500"
        />
        <Search class="absolute top-2.5 left-3 text-gray-400 w-5 h-5" />
      </div>

      {#if searchTerm.length > 0 && $totalItems > 0}
        <button
          on:click={deleteFilteredSymlinks}
          class="btn btn-red-deep whitespace-nowrap"
          disabled={$bulkDeleting}
        >
          {#if $bulkDeleting}
            <Loader2 class="w-4 h-4 animate-spin text-white" /> Suppression...
          {:else if $bulkDeleteSuccess}
            <CheckCircle2 class="w-4 h-4 text-white" /> Supprim√©s !
          {:else}
            <Trash class="w-4 h-4" /> Supprimer {$totalItems} symlink{s($totalItems)} filtr√©{s($totalItems)}
          {/if}
        </button>
      {/if}
    </div>

    <!-- üìÇ Filtre dossier -->
    <div class="relative w-full sm:w-1/4">
      <select
        bind:value={$selectedDir}
        on:change={() => {
          currentPage.set(1);
          refreshList();
        }}
        class="appearance-none w-full pl-10 pr-10 py-2 rounded-lg bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-600 text-gray-900 dark:text-gray-200 shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all duration-200 ease-in-out hover:scale-[1.01]"
      >
        <option value="">üìÅ Tous</option>
        {#each $availableDirs as dir}
          <option value={dir}>üìÇ {dir}</option>
        {/each}
      </select>

      <div class="absolute inset-y-0 left-3 flex items-center pointer-events-none">
        <FolderSearch class="w-4 h-4 text-yellow-500 dark:text-yellow-400" />
      </div>

      <div class="absolute inset-y-0 right-3 flex items-center text-gray-400 dark:text-gray-500 pointer-events-none">
        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
        </svg>
      </div>
    </div>

    <!-- üî¢ Pagination -->
    <div class="w-full sm:w-1/5">
      <select
        on:change={(e) => {
          const newValue = +e.target.value;
          rowsPerPage.set(newValue);
          currentPage.set(1);
          refreshList();
        }}
        class="w-full border border-gray-300 dark:border-gray-700 bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-200 rounded-lg px-3 py-2"
      >
        <option value="10">10</option>
        <option value="25">25</option>
        <option value="50">50</option>
        <option value="100">100</option>
      </select>
    </div>
  </div>

{#if $showLatest}
  <!-- Derniers symlinks uniquement (pas de pagination) -->
  <div class="mt-10">
    <div class="relative mb-4 flex items-center">
        <span
            class="mr-2 flex items-center justify-center w-6 h-6 rounded-full 
                   bg-gradient-to-tr from-pink-500 via-purple-500 to-indigo-500
                   text-white shadow-md animate-pulse-slow"
        >
            <Sparkles class="w-4 h-4 animate-spin-slow" />
        </span>

        <span class="text-sm md:text-base lg:text-lg 
                     bg-gradient-to-r from-indigo-400 via-purple-400 to-pink-500 
                     bg-clip-text text-transparent">
            10 Derniers symlinks ajout√©s
        </span>
    </div>

    <div class="space-y-4">
      {#each $latestSymlinks as item}
        <div
          class="relative p-5 rounded-2xl bg-white dark:bg-gray-800 
                 border border-gray-200 dark:border-gray-700
                 shadow-md hover:shadow-lg transition-transform duration-200 hover:-translate-y-0.5"
        >
          <!-- Header -->
          <div>
            <p class="text-sm font-bold font-mono text-gray-900 dark:text-gray-50 break-all">
              {item.symlink}
            </p>
            <p class="mt-1 text-sm font-mono text-gray-600 dark:text-gray-400 break-all">
              ‚Ü≥ {item.target}
            </p>
          </div>

          <!-- Footer : badges + actions -->
          <div class="mt-3 flex flex-wrap gap-3 items-center justify-between">
            <!-- Badges -->
            <div class="flex flex-wrap gap-3 items-center">
              <!-- Ref Count -->
              <span
                class="inline-flex items-center gap-1 px-3 py-1 rounded-full font-semibold text-xs
                       {item.ref_count === 0
                         ? 'bg-red-100 text-red-700 dark:bg-red-800 dark:text-red-300 border border-red-300 dark:border-red-600'
                         : 'bg-green-100 text-green-700 dark:bg-green-800 dark:text-green-300 border border-green-300 dark:border-green-600'}"
              >
                {item.ref_count === 0 ? '‚ö†' : '‚úî'} Ref Count: {item.ref_count}
              </span>

              <!-- Type (badge cliquable) -->
              {#if item.type && ['radarr', 'sonarr'].includes(item.type.toLowerCase())}
                <button
                  on:click={() => openArr(item)}
                  class="inline-flex items-center gap-1 px-3 py-1 rounded-full font-semibold text-xs
                         bg-emerald-100 text-emerald-700 
                         dark:bg-emerald-800 dark:text-emerald-300 
                         border border-emerald-300 dark:border-emerald-600
                         hover:scale-105 transition-transform"
                >
                  üì¶ {item.type.toLowerCase()}
                </button>
              {/if}
            </div>

            <!-- Actions dynamiques -->
            {#if item.ref_count === 0 || item.target_exists === false}
              <!-- Lien cass√©/orphan ‚Üí bouton R√©parer -->
              <button
                on:click={() => deleteSymlink(item)}
                class="flex items-center gap-2 px-2 py-1 rounded-lg transition-transform hover:scale-105"
                aria-label="R√©parer"
                title="R√©parer"
              >
                <div class="grid h-8 w-8 place-items-center rounded-md bg-gradient-to-br from-rose-500 via-orange-500 to-amber-400 shadow">
                  <svg viewBox="0 0 24 24" class="h-5 w-5 text-white">
                    <path fill="currentColor" d="M12 2s5 3.5 5 8.5S15 20 12 22c-3-2-5-5-5-9.5S12 2 12 2z"/>
                  </svg>
                </div>
                <span class="text-sm font-semibold tracking-wide bg-gradient-to-r from-rose-500 via-orange-500 to-amber-400 bg-clip-text text-transparent">
                  R√©parer
                </span>
              </button>
            {:else if item.type === 'sonarr'}
              <!-- Sonarr ‚Üí bouton Seasonarr -->
              <button
                on:click={() => deleteSymlink(item)}
                class="flex items-center gap-2 px-2 py-1 rounded-lg transition-transform hover:scale-105"
                aria-label="Seasonarr"
                title="Seasonarr"
              >
                <div class="grid h-8 w-8 place-items-center rounded-md bg-gradient-to-br from-rose-500 via-orange-500 to-amber-400 shadow">
                  <svg viewBox="0 0 24 24" class="h-5 w-5 text-white">
                    <path fill="currentColor" d="M12 2s5 3.5 5 8.5S15 20 12 22c-3-2-5-5-5-9.5S12 2 12 2z"/>
                  </svg>
                </div>
                <span class="text-sm font-semibold tracking-wide bg-gradient-to-r from-rose-500 via-orange-500 to-amber-400 bg-clip-text text-transparent">
                  Seasonarr
                </span>
              </button>
            {:else}
              <!-- Corbeille classique -->
              <button
                on:click={() => deleteSymlink(item)}
                class="p-1.5 rounded-full border border-red-400 text-red-500
                       hover:bg-red-50 dark:hover:bg-red-900/30 transition-colors"
                disabled={$deleting[item.symlink]}
                aria-label="Supprimer"
                title="Supprimer"
              >
                {#if $deleting[item.symlink]}
                  <Loader2 class="w-4 h-4 animate-spin" />
                {:else if $deleteSuccess[item.symlink]}
                  <CheckCircle2 class="w-4 h-4 text-green-500" />
                {:else}
                  <Trash2 class="w-4 h-4" />
                {/if}
              </button>
            {/if}
          </div>
        </div>
      {/each}
    </div>
  </div>
{:else}
  <!-- Tableau principal avec pagination -->
  <!-- Pagination TOP -->
  <Pagination
    page={$currentPage}
    totalItems={$totalItems}
    pageSize={$rowsPerPage}
    on:changePage={(e) => goToPage(e.detail)}
  />

  <div class="space-y-4 mt-6">
    {#each $symlinks as item}
      <div
        class="relative p-5 rounded-2xl bg-white dark:bg-gray-800 
               border border-gray-200 dark:border-gray-700
               shadow-md hover:shadow-lg transition-transform duration-200 hover:-translate-y-0.5"
      >
        <!-- Header -->
        <div>
          <p class="text-sm font-bold font-mono text-gray-900 dark:text-gray-50 break-all">
            {item.symlink}
          </p>
          <p class="mt-1 text-sm font-mono text-gray-600 dark:text-gray-400 break-all">
            ‚Ü≥ {item.target}
          </p>
        </div>

        <!-- Footer : badges + delete button -->
        <div class="mt-3 flex flex-wrap gap-3 items-center justify-between">
          <div class="flex flex-wrap gap-3 items-center">
            <!-- Ref Count -->
            <span
              class="inline-flex items-center gap-1 px-3 py-1 rounded-full font-semibold text-xs
                     {item.ref_count === 0
                       ? 'bg-red-100 text-red-700 dark:bg-red-800 dark:text-red-300 border border-red-300 dark:border-red-600'
                       : 'bg-green-100 text-green-700 dark:bg-green-800 dark:text-green-300 border border-green-300 dark:border-green-600'}"
            >
              {item.ref_count === 0 ? '‚ö†' : '‚úî'} Ref Count: {item.ref_count}
            </span>

            <!-- Type (badge cliquable) -->
            {#if item.type && ['radarr', 'sonarr'].includes(item.type.toLowerCase())}
              <button
                on:click={() => openArr(item)}
                class="inline-flex items-center gap-1 px-3 py-1 rounded-full font-semibold text-xs
                       bg-emerald-100 text-emerald-700 dark:bg-emerald-800 dark:text-emerald-300 border border-emerald-300 dark:border-emerald-600
                       hover:scale-105 transition-transform"
              >
                üì¶ {item.type.toLowerCase()}
              </button>
            {/if}
          </div>

          <!-- Bouton dynamique -->
          {#if item.ref_count === 0 || item.target_exists === false}
            <!-- Si lien cass√©/orphan ‚ûú bouton R√©parer -->
            <button
              on:click={() => deleteSymlink(item)}
              class="flex items-center gap-2 px-2 py-1 rounded-lg transition-transform hover:scale-105"
              aria-label="R√©parer"
              title="R√©parer"
            >
              <div class="grid h-8 w-8 place-items-center rounded-md bg-gradient-to-br from-rose-500 via-orange-500 to-amber-400 shadow">
                <svg viewBox="0 0 24 24" class="h-5 w-5 text-white">
                  <path fill="currentColor" d="M12 2s5 3.5 5 8.5S15 20 12 22c-3-2-5-5-5-9.5S12 2 12 2z"/>
                </svg>
              </div>
              <span class="text-sm font-semibold tracking-wide bg-gradient-to-r from-rose-500 via-orange-500 to-amber-400 bg-clip-text text-transparent">
                R√©parer
              </span>
            </button>
          {:else if item.type === 'sonarr'}
            <!-- Si Sonarr ‚ûú bouton Seasonarr -->
            <button
              on:click={() => deleteSymlink(item)}
              class="flex items-center gap-2 px-2 py-1 rounded-lg transition-transform hover:scale-105"
              aria-label="Seasonarr"
              title="Seasonarr"
            >
              <div class="grid h-8 w-8 place-items-center rounded-md bg-gradient-to-br from-rose-500 via-orange-500 to-amber-400 shadow">
                <svg viewBox="0 0 24 24" class="h-5 w-5 text-white">
                  <path fill="currentColor" d="M12 2s5 3.5 5 8.5S15 20 12 22c-3-2-5-5-5-9.5S12 2 12 2z"/>
                </svg>
              </div>
              <span class="text-sm font-semibold tracking-wide bg-gradient-to-r from-rose-500 via-orange-500 to-amber-400 bg-clip-text text-transparent">
                Seasonarr
              </span>
            </button>
          {:else}
            <!-- Sinon ‚ûú corbeille classique -->
            <button
              on:click={() => deleteSymlink(item)}
              class="p-1.5 rounded-full border border-red-400 text-red-500
                     hover:bg-red-50 dark:hover:bg-red-900/30 transition-colors"
              disabled={$deleting[item.symlink]}
              aria-label="Supprimer"
              title="Supprimer"
            >
              {#if $deleting[item.symlink]}
                <Loader2 class="w-4 h-4 animate-spin" />
              {:else if $deleteSuccess[item.symlink]}
                <CheckCircle2 class="w-4 h-4 text-green-500" />
              {:else}
                <Trash2 class="w-4 h-4" />
              {/if}
            </button>
          {/if}
        </div>
      </div>
    {/each}
  </div>
  <!-- Pagination BOTTOM -->
  <Pagination
    page={$currentPage}
    totalItems={$totalItems}
    pageSize={$rowsPerPage}
    on:changePage={(e) => goToPage(e.detail)}
  />
{/if}

</main>

<style>
    .btn {
        @apply inline-flex items-center gap-2 justify-center px-4 py-2 text-sm font-medium rounded-md shadow-sm transition-transform duration-200 hover:scale-[1.02] focus:outline-none focus-visible:ring-2 focus-visible:ring-offset-1 disabled:opacity-50 disabled:pointer-events-none;
    }

    .btn-blue {
        @apply bg-blue-500 hover:bg-blue-600 text-white focus-visible:ring-blue-300;
    }

    .btn-gray {
        @apply bg-gray-500 hover:bg-gray-600 text-white focus-visible:ring-gray-300;
    }

    .btn-emerald-deep {
        @apply bg-emerald-700 hover:bg-emerald-800 text-white focus-visible:ring-emerald-500;
    }

    .btn-red-deep {
        @apply bg-red-700 hover:bg-red-800 text-white focus-visible:ring-red-500;
    }

    .btn-indigo-deep {
        @apply bg-indigo-600 hover:bg-indigo-700 text-white focus-visible:ring-indigo-400;
    }

    .btn-yellow-deep {
        @apply bg-yellow-500 hover:bg-yellow-600 text-white focus-visible:ring-yellow-300;
    }

    .animate-pulse-strong {
        animation: pulseStrong 1.5s infinite;
    }

    @keyframes pulseStrong {
        0%, 100% {
            transform: scale(1);
            opacity: 1;
        }
        50% {
            transform: scale(1.05);
            opacity: 0.85;
        }
    }
</style>
